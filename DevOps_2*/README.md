## Задачи
1. Написать “плохой” `Docker compose` файл, в котором есть не менее трех “bad practices” по их написанию
2. Написать “хороший” `Docker compose` файл, в котором эти плохие практики исправлены
3. В `Readme` описать каждую из плохих практик в плохом файле, почему она плохая и как в хорошем она была исправлена, как исправление повлияло на результат
4. После предыдущих пунктов в хорошем файле настроить сервисы так, чтобы контейнеры в рамках этого compose-проекта так же поднимались вместе, но не "видели" друг друга по сети. В отчете описать, как этого добились и кратко объяснить принцип такой изоляции
## Что за проект?
Для участия в одном практикуме было предложено написать `docker compose` файл для развертывания одного незамысловатого приложения на `python` с бд `postgresql`, [ссылка на репозиторий с выполненным мной заданием](https://gitlab.com/a1191245/devops-sample-django-app), плохой `docker compose` возьму оттуда и доработаю =) 

## `Docker compose` файлы
### "Плохой"

![](img/Pasted%20image%2020241130161020.png)
### "Хороший"
![](img/Pasted%20image%2020241130160631.png)
### Что исправилось?
1. `Environmental variables` были вынесены в отдельный файл `.env`. В них хранятся пароли, которые хорошо бы не выносить в открытый доступ (где `docker compose` как раз может храниться), а оставлять в отдельном файле. Также такой подход делает `docker compose` более безопасным и гибким, т.е если нужно поменять переменные для другой среды, то просто подгружаем новый `.env` файлик, не меняя `docker compose`.
2. Вместо костыля с использованием стороннего скрипта `wait-for-it.sh` (для того, чтобы бд была готова к работе, т.к `depends on` обеспечивает только готовность контейнера, а не бд) был использован `healthcheck`. В целом использование костылей это явно `bad practice`, когда есть встроенная в `docker compose` замена. 
3. Добавлены ограничения по ресурсам `mem_limit` и `cpus`. Если вдруг внутри приложения возникнет какая-то ошибка, расходующая все ресурсы контейнера - это никак не коснётся нашего хоста (и других контейнеров) и можно будет пофиксить ошибку (а так вдруг хост от нехватки ресурсов зависнет и всё...).
## Пруфы, что всё работает
### "Плохой" `Docker compose` файл
>[!NOTE] 
>Можно отличить по отсутсвию `.env` и по наличию `wait-for-it.sh`

![](img/Pasted%20image%2020241130151740.png)
![](img/Pasted%20image%2020241130155631.png)
### "Хороший" `Docker compose` файл
>[!NOTE] 
>А вот тут `.env` появился, а `wait-for-it.sh` исчез

![](img/Pasted%20image%2020241130164111.png)
![](img/Pasted%20image%2020241130154139.png)
## Изоляция контейнеров
Изначально `docker compose` создаёт общую сеть для всех сервисов, где они могут общаться. Теперь же каждый сервис помещён в отдельную сеть (`site_network` и `db_network`).
![](img/Pasted%20image%2020241130170229.png)
Видим, что создались две сети:
![](img/Pasted%20image%2020241130170422.png)

И ещё видим, что теперь ничего не работает, потому что первый сервис с приложением напрямую зависит от второго сервиса с бд =).
![](img/Pasted%20image%2020241130170533.png)

В целом изоляция - полезная штука, если сервисы независимы друг от друга.